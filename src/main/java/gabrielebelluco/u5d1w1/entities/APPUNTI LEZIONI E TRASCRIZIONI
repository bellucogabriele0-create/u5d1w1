@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@LEZIONE 1 Spring INTRO@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
spring è il nostro framework di riferimento
per poter capire come scrivere del codice per del web server allora sarà essenziale capire come funziona spring.
Spring ci consente di automattizzare tutti quei passaggi dove c'è una richiesta,leggerne il contenuto,
interpretarlo, fornirci oggetti e poi darci delle risposte e può farne anche più di una di queste azioni alla volta
e questo permetterà a noi di focalizzarci sulla business logic ovvero ciò che deve davvero fare l'app delegando le cose
ripetitive a spring anche per esempio alle cose relattive alla sicurezza dell'app ci possiamo servire di spring security
anche per il discorso della manipolazione dei dati dal db usufruiremo di spring. Parlando di una delle cose più
ricorrenti che un programmatore deve fare è quella di creare oggetti come per esempio nell'ultima buildweek abbiamo
fatto circa 10 dao e nel main di conseguenza neabbiamo dovuti creare altre tanti, e se gli stessi dao servissero anche
in altri punti dell'app allora li dovremmo rifarne altre tanti quindindi diventerebbe un bel lavorone ripettitivo,
inoltre le app che abbiamo fatto fin ora, vivono solo nel main ma la verità è che la logica viene utilizzata in più
e più parti, quindi quello stesso dao avrei bisogno di usarlo in più parti, ecco che qua ci viene in soccorso Spring
che creerà oggetti per noi quindi io delego questo compito a spring, io prima creo i dao come classe e gli oggetti
glieli lascio creare a lui pronti all'avvio, attenzione però lui non mi andrà a creare l'user aldo giovanni e giacomo etc.
no si intende quegli oggetti che sono strumenti come i dao o come il faker per esempio, oppure poter rendere disponibile
il dao senza dover istanzire più volte un'oggetto grazie a un'annotazione che ci consentirà di renderlo diponibile
in tutta l'applicazione e questo ragionamento dei dao si potrà applicare a tante altre classi.
quindi con un approccio dichiarattivo io gli dico cosa voglio e spring dietro ha una serie di algoritmi che producono il
risultato ovvero la creazione di quegli strumenti citati prima, ma saprà creare oggetti non solo prima dell'avvio
dell'app ma anche durante l'esecuzione come per esempio quando abbiamo un web server e mi arriverà una richiesta
spring creerà un'oggetto per quella richiesta e me lo metterà a disposizione in maniera tale che io riesca a leggere
quello che c'è nel payload negli headers e quindi noi saremo in grado di accedere alla richiesta http e in una
maniera simile saremo in grado di capire come lui riesce a creare delle risposte, anche l'entityManager e factory
verranno fatti da spring e non da noi.
SPRING BOOT
Spring boot e spring sono correlati ma non sono la stessa cosa che ci permetterà di scrivere ancora meno codice, perchè
spring necessita di una sorta di settaggio per essere uttilizzato invece spring boot ci evita tutta questa parte creando
una sorta di default che vada bene in generale sempre sovrascrivibile ma già pronto ad essere visualizzato (un po come i
colori primary danger secondary warning di react).
Per iniziare un progetto spring esistono due metodi da browser o da intellij ma saranno identici a differenza che da
intellij servirà un plugin, per fare ciò da browser andiamo su Spring initialzr, e configuriamo le scelte che ci servono
ovvero:  maven / java / 4.0.2 / gropu:gabrielebelluco / artefact: u5d1w1 / pack jar / config : Properties/ Java : 21
e nelle dependencies possiamo scegliere dei pacchetti da aggiungere come spring web, spring data, postgres, lombok,
security e altri successivamente facciamo generate e ci scaricherà uno .zip che dovremo aprire con intellij.
invece da intellij con il plugin è con "start spring booot project" e i passaggi saranno identici al browser.
BEANS
tutta la parte di delegazione degli oggetti parte dai beans i beans sono degli oggetti gestiti da spring come i
dao, ma ci sono anche altri esempi come abbiamo già detto, come le richieste http che sono rappresentate da un oggetto
che noi esploreremo, ne leggiamo il contenuto, quindi immaginiamoci un'oggetto di una certa classe che conterrà la
richiesta che è appena arrivata e chi crea quell'oggetto/Strummetno è spring e noi lo utilizziamo. stessa cosa per i dao
prendiamo tutti i dao di cui abbiamo bisogno e diaciamo a spring, spring all'avvio li crea e li mette in una sorta di
scattolone (CONTAINER) in cui all'interno ci saranno tutti questi oggetti e noi prendiamo quello che ci serve, e la
cosa interessante è che spring ad es. per i dao non creerà moltecipli oggetti ma ne creerà uno solo utilizzabile in
tutta l'applicazione, perchè un dao è semplicemente un oggetto con dei metodi quindi non è che deve essere diverso ogni
volta che lo utilizzamo.
Spring Container
quello che abbiamo chiamato contenitore prima in realtà ha più nomi, ma in generale è chiamato Container e in spring
abbiamo due nomi principali BeanFactory e l'ApplicationContext(che è quello utilizzato da noi perchè è funzionale).
quindi immaginiamoci come se in una parte dell'applicazione troviamo questo container chiamato Spring Application Context
con all'interno tutti i beans all'interno. Quando noi scriviamo il codice decidiamo quali classi far gestire a spring
e quali no e tutte le classi che noi scegliamo di far gestire a Spring all'avvio dell'applicazione crea lo scattolone
e ci mette tutti i beans/oggetti all'interno (un po come la cassetta degli attrezzi detta prima con all'interno tutti i
dao già pronta) e non importerà se noi siamo nel main o in qualsiasi altro punto noi potremmo accedere
all'applicationcontext e prendere gli oggetti che ci servono. e il nostro compito sarà quello di capire come fare a
mettere dentro il context ciò che noi vogliamo metterci all'interno e dare le istruzioni per poter sfruttare gli oggetti,
e per fare ciò ci sono diversi metodi, invece gli altri oggetti creati da noi saranno oggetti classici creati da noi e
saranno fuori dal context. ci sono 3 diverse strade per istruire spring:
1 dichiarazione xml: (non più utilizzato)
2 Configurazione basata su Java: (utilizzato grazie a @Configuration @bean)
3 Configurazione basata su annotazioni ()
Noi utilizzeremo un' approccio dichiarattivo noi dichiariamo cosa vogliamo e lui realizzerà cio che vogliamo.
XML
la dichiarazione con xml avrà una struttura del genere:
<beans> qui ci andrà tutta l'intestazione
  <bean (qui ci andrà l'id) id="personBean" (qui ci andrà la classe a qui ci riferiamo ) class="com.example.Person" >
    <property (e qui gli attributi per il suo costruttore) name="name" value="don joe"/>
    <property name="age" value="30"/>
  </beans>
</beans>
logicamente all'interno si possono creare anche più bean basta aggiungerli all'interno del "beans" ma possono essere
anche collegati tra di loro grazie all'autowire
  <bean id="orderBean" class="com.example.Order" autowire="byType" >
quindi questo gli consentirà di creare anche oggetti complessi perchè avrà una dipendenza verso un'altro.
Quindi una volta creati i Bean li leggiamo dall'ApplicationContext, ci sono più modi per leggerli dal context
2 CONFIGURAZIONE BASATA SU JAVA:
questo approccò farà le stesse cose ma con java quindi ci permetterà di scrivere codice controllato da intellij, o
aggiungere anche logiche come funzioni cicli, essa però prevede la creazione di una classe che si chiamerà classe di
configurazione al cui interno metteremo dei metodi i quali mi torneranno dei bean quindi all'interno metterò delle
istruzioni che spiegerà a spring come crearmi quel particolare bean, notiamo che nel'immagine ci sono due
annotazioni principali esse sono @Configuration e @Bean.
@Configuration si mette a livello di classe non di metodo per far capire a spring che questa è una classe di
configuration altrimenti sarebbe una classe come un'altra
@Bean si mette a livello di metodo e se ne mettiamo più di uno dovremmo metterlo a ognuna altrimenti viene ignorato.
con una struttura come questa:
@Bean
pulblic Person personBean () {
     Person person = new person();
     person.setName("don Joe");
     person.setAge(30);
     Return person;
}
quindi le graffe che vediamo qua ci consentiranno di creare anche della logica molto complessa l'importante è che ci
ritorni person come abbiamo qua, allo stesso modo posso far tornare liste, stringhe, numeri, array quello che voglio
quindi non solo l'oggetto singolo come in questo caso ma anche cose più semplici o più complesse.
Un altro caso è questo:
@Bean
public Customer customerBean() {
    Person person = new person();
    person.setName("don Joe");
    return customer;
}

@Bean
public Order orderBean(Customer customer){
return new Order (customer)
}
qua creiamo una dipendenza perchè gli stiamo dicendo che per creare il bean di tipo Order deve creare un bean di
tipo Customere dentro le graffe gli diremo come si creeranno gli ordini e l'ordine ha un parametro customer che deriva
dallo stesso parametro del metodo, però come farà a capire chi scegliere come customer? ciò che succede dietro le quinte
è che spring rileva la classe di configurazione, sceglie i metodi con i @bean poi li mette nel container,
successiavamente prende quelli con dipendenze e controlla quali hanno lo stesso nome delle dipendenze, prende in questo
caso il customer e glielo passa. quindi a questo punto abbiamo dato istruzioni per creare gli oggetti usare il metodo
crearlo e meterlo dentro il container per poterlo mettere a disposizione, a disposizione dell'applicationContext ctx
per poter accedere a quegli oggetti e poi possiamo prendere gli oggetti di tipo person, customer, order etc.
dunque facciamo degli esempi, creiamo una cartella entities con una classe padre e student e più classi figlie BackendStudent
FrontendStudent e FullstackStudent
 quindi creiamo una classe astratta padre Student
public abstract class Student {
    @Setter(AccessLevel.NONE) // Serve per eliminare il setter automatico su un campo specifico
 	private UUID id;
	private String name;
	private String surname;

	public abstract void answerQuestion(); // che ci darà un S.o.p diverso l'uno dall'altro
}
nelle classi figlie invece creiamo il costruttore delle con il super,il toString e l'Override del answerQuestion così:
	@Override
	public void answerQuestion() {
		System.out.println("Ciao sono lo studente BACKEND e la risposta alla domanda è...blablbalba");
	}
	@Override
	public String toString() {
		return "BackendStudent{} " + super.toString();
	}
aggiungiamo anche una classe config nel package config che è una classe "speciale " all'interno dell'applicazione.
Essendo annotata da @Config, questo significa che al suo interno potremo inserire N metodi, ognuno dei quali conterrà
le "istruzioni" per generare un Bean, ovvero per chiedere Spring di gestire lui quell'oggetti ed inserirlo
nell'application Context (lo "scattolone"), per creare un nuovo @Bean aggingiamo un metodo con annotazioni @Bean per
esempio
@Bean
public int getNumber() {
  return 42;
  }

  @Bean
  public String getAdminName() {
  return "ajeje";
  }
 @Bean public FrontendStudent getFEStudent() {
 return new frontendStudent("Aldo", "Baglio");
 }
@Bean public backendStudent getBEStudent(){
return new BackendStudent ("Giovanni", "Storti")
}
@Bean
public FullstackStudent getFSStudent() {
 return new FullstackStudent ("Giacomo", "Poretti");
}

e ora nel main andiamo a scrivere la lettura BEANS da CONTEXT, seguendo questi passaggi:
1.Ottengo un riferimento al context
2. Tramite metodi .getBean dell'oggetto context possso leggere i bean dallo scattolone e posso usarlicome oggetti normalissimi
1. =
AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(U5d1w1Application.class);
all'interno delle tonde si da la classe di riferimento che viene passata al costruttore "AnnotationConfigApplicationContext"
e poi lui mi torna un'oggetto ctx. Infatti adesso nel passaggio 2. se scriviamo ctx.getBean abbiamo due modalità di
recuperare il bean attraverso la prima è tramite nome e l'altra è tramite classe la differenza sta nel tipo di ritorno
se uttilizzo tramite nome mi torna un'object generico il quale poi dovrò fare un cast, invece l'altra è passando il tipo
della classe lui me la tipizzerà già con il tipo giusto
_
FrontendStudent fes = ctx.getBean(frontendStudent.class);
S.o.p(fes);
_
e questo nel terminale mi stamperà: FrontendStudent{} Student {name='Aldo' , surname='Baglio'}

oppure possiamo fare anche: fes.answerQuestion
questo per far capire che dunque diventa un'oggetto utilizzabile. quindi fin'ora nel main non abbiamo mai creato
oggetti nel main questo perchè viene auto generato da spring messo dentro ctx e poi da ctx posso estrarre ciò che serve
in caso avessimo più oggetti dello stesso tipo potremo avere dei problemi di ambiguità, allora lì entra in gioco il discorso
del nome come abbiamo detto prima i bean possono essere letti per nome, e per ciò c'è una ragione, inanzitutto il nome
del bean se non specificato in un altro modo è il nome del metodo in questo caso ad esempio è "getFEStudent()"  e nel
main scriveremo FrontendStudent fes2 = ctxgetBean("getFEStudent"); il problema qua è che lui mi tornerà un object quindi
bisognerà castare altrimenti FrontendStudent fes2 = ctx.getBean("getFEStudent", FrontendStudent.class); e qua il
risultato è sempre lo stesso dunque
FrontendStudent{} Student {name='Aldo' , surname='Baglio'}  Ciao sono lo studente BACKEND e la risposta alla domanda è...blablbalba
oppure possiamo specificare il nome direttamente al bean così:
 @Bean(name= "aldo")
 public FrontendStudent getFEStudent() {
 return new frontendStudent("Aldo", "Baglio");
 }
dunque opzionalmente posso nominare un bean, altrimenti verrà utilizzato il nome del metodo.
ora mettiamo il caso che il bean in ConfigClass abbia un parametro del tipo:
@Bean
public FullstackStudent getFSStudent(String name) {
 return new FullstackStudent (name, "Poretti");
}
a questo punto nel main se noi creassimo un oggetto del tipo :
FullstackStudent fss = ctx.getBean(FullstackStudent.class);
S.o.p(fss);
nel terminale ci stamperà
FullstackStudent{} Student {name='Ajeje' , surname='Poretti'}
questo perchè prima ho definito un bean di tipo stringa che mi torna ajeje riga 146 che gli abbiamo passato come parametro
quindi lui la cercherà nello scattolone e se lo trova lo passa altrimenti darà un'errore. invece se ci fosserò più di un
bean di tipo String noi dobbiamo essere chiari con quale dei due vogliamo passare
 @Bean
 public String getAdminName2() {
 return "Claudio"
 }
 ma lo vediamo meglio dopo e ciò che
abbiamo fatto passando il parametro è chiamata DIPENDENZA.
ora per rendere più chiaro il concetto ci creiamo un'altra entity di nome Interviewer e gli passiamo come attributo Student
in modo da poter fare i colloqui a tutti gli studenti, in questo modo:
public class Interviewer {
  private Student student;

  public Interviewer (Student student) {
  this.student = student;
  }
  public void askQuestion() {
  S.o.p("Ciao "+ student.getName() + ", rispondi alla seguente domanda.... #####"
  this.student.answerQuestion();
  }
}
quindi con questo esempio vediamo che c'è una connessione tra una classe e un'altra, tra interviewer e student e anche
questa è una dipendenza  e significa che quando creiamo un'interviewer deve esistere già uno studente non può essere
creato dopo lo studente, un po come le relazioni tra le varie tabelle, ad esempio non posso creare l'abbonamente se
non c'è l'utente. Dunque cosa succede se io creo un bean di tipo Interviewer nella ConfigClass? del tipo:
@Bean
public Interviewer getInterviewer(FullstackStudent, student) {
 return new Interviewer(student);
}
questo esempio è molto simile a quello creato nel bean dove passavamo String name. dunque per testare andiamo nel main
e creiamo Interviewer nello scattolone in questo modo:
Interviewer i = ctx.getBean(Interviewer.class);
i.askQuestion();
e ciò stamperà:
 Ciao Claudio, rispondimi allaseguente domanda...#####
 Ciao sono lo studente FULLSTACK e la risposta alla domanda è....blablabla
ciò che succede nella console è che Interviewer grazie a @Bean viene creato come oggetto, prende uno student,
ma prende quello  indicato dal tipo "FullstackStudent", ne abbiamo solo uno che prende il nome da getAdmin2
(getInterviewer<getFSStudent<getAdmin2)
quindi un'altra delle cose importanti di spring è che non solo crea oggetti ma riesce anche a collegarli uno all'altro
dunque in questo ultimo esempio noi avremmo il parametro Student che è una dipendenza del Bean Interviewer.
ora facciamo l'esempio che invece di passare FullstackStudent passiamo Student così:
@Bean
public Interviewer getInterviewer(Student, student) {
 return new Interviewer(student);
}
ecco che quà ci darà un errore perchè troverà tre studenti (Aldo, getBEStudent,getFSStudent) perchè c'è di mezzo il
polimorfismo, QUINDI è MEGLIO EVITARE.
RICAPITOLANDO ciò che possiamo riassumere da quanto visto fin'ora è che possiamo creare dei bean nella classe di
configurazione quindi riempire il container (scattolone) estrarrli quando abbiamo bisogno di utilizzarli con il get bean
però ci sono tutte quelle dinamiche da tenere in considerazione nel senso non possiamo dichiarare dei bean uguali e
pretendere che attraverso il tipo lui riesca a capire come distinguerli, non possiamo non dichiarare un bean che è
necessario per un'altro bean, mancanze, se ci manca il FullstackStudent ci da errore, in caso di parametro errato ci
da errore perchè trova 3 risultati, e per questo il primary è una delle annotazioni che si possono dare per evvitare
che si cada nell'errore, nel senso che mettendo come in questo caso ci sono tre Student e ne mettiamo uno come @Primary
risolverò l'ambiguità in questo modo:
@Bean
@Primary
public FullstackStudent getFSStudent(String name) {
 return new FullstackStudent (name, "Poretti");
}
Dunque l'annotazione primary dice in caso di ambiguità preferisci lui, come se fosse una sorta di default.
BEAN SCOPE
cosa è uno scope? lo scope determina il comportamento di questi bean.
 IL SINGLETON: significa che quando all'interno di un'applicazione viene creato un'oggetto, quell'oggetto è unico singolo
l'unica coppia che esiste all'interno di quell'applicazione è quello il primo ad essere creato, ulteriori tentativi di
creazione falliscono o verrà restituito sempre lo stesso oggetto, sempre la stessa locazione di memoria, quindi di default
tutti i bean sono Singleton, infatti quando abbiamo creato i due oggetti identici fes e fes2 in realtà sono lo stesso
essendo singleton, a meno di non cambiare lo scope da singleton a qualcos'altro. questa caratteristica del singleton è
molto  importante perchè quando abbiamo ad esempio i DAO non ha senso crearsi gli oggetti DAo ogni volta che li richiedo,
ne basterà uno per tutta l'applicazione, quindi il fattore che siano singleton mi crea il dao e ogni volta che devo usare
il dao non è che lo ricrea mi da sempre un riferimento allo stesso oggetto perchè non ha senso crearne una copia e sarebbe
anche uno sprecco di spazio, ciò avrà anche dei contro nel senso che se avessimo dei setter in un esempio del genere:
FrontendStudent fes = ctx.getBean( FrontendStudent.class);
S.o.p(fes);
fes.setName("Mario");
FrontendStudent fes2 = ctxgetBean("getFEStudent", FrontendStudent.class)
S.o.p(fes2);
succederà questo, primo passaggio: estraggo il bean FrontendStudent dallo scattolone che si chiama "Aldo"-> stampo e in
console avrò FrontendStudent{} Student {name='Aldo' , surname='Baglio'} -> setto il nome a "Mario" -> estraggo dinuovo
il nome con il getBean dallo scattolone aldo ma non è più aldo è Mario questo per far capire che sono entrambi un'oggetto
solo ma ricchiamato più volte in modi diversi. questo può essere cambiato ma non è detto che ci sia utile, ad esempio
scope PROTOTYPE è L'OPPOSTO di Singleton cioè ogni volta che faccio getbean mi viene creato una coppia dell'oggetto
dunque a meno che non sia necessario è meglio singleton ad esempio
@Bean
@Scope("prototype")
 public FrontendStudent getFEStudent() {
 return new frontendStudent("Aldo", "Baglio");
 }
questo farà in modo che stamperà
FrontendStudent{} Student {name='Aldo' , surname='Baglio'}
FrontendStudent{} Student {name='Aldo' , surname='Baglio'}
percè nel primo passaggio ora è aldo ma non ristampiamo dopo il settaggio del nome e nel secondo stampiamo aldo però essendo
PROTOTYPE creerà un'altro oggetto aldo baglio.
quindi scope è un'annotazione opzionale se non è specificato è singleton di default,
SINGLETON:in tutta l'applicazione esiste un'unica coppia dell'oggetto. Ogni volta che faccio getBean() mi torna sempre
stesso oggetto
PROTOTYPE: ogni volta che uso getBean mi torna una nuova copia dell'oggetto.
LOMBOK:
è uno strummento da non uttilizzare in azienda ma utile per prototipi o codice di prova quando questo ci aiuta con le
varie annotazioni a creare per esempio
@Data: crea equals, getter e setter, toString, hashCode per tutti i campi della classe
@Getter, @Setter : generano i getter e setter
@NoArgsConstructor e @AllArgsConstructor: Generano costruttori sia vuoto che pieno
@ToString: genera un metodo toString per la classe (problemi di bidirezionalità)
@EqualsAndHashCode: genera metodi equals e hashCode per la classe.
@Builder: fornisce un modello di progettazione del tipo Builder per creare oggetti immutabili in modo fluente.
Nel caso in cui noi volessimo non settare l'UUID come molto spesso capita, dobbiamo mettere sopra il campo desiderato
per esempio @Setter(AccessLevel.NONE)

RIASSUNTO
Spring è il framework di riferimento per lo sviluppo Java. Il suo scopo principale è automatizzare i compiti ripetitivi
(gestione richieste HTTP, sicurezza, connessione al database) per permettere allo sviluppatore di concentrarsi solo sulla Business Logic.
Approccio Dichiarativo: Non scriviamo noi il "come" fare le cose (es. istanziare oggetti), ma diciamo a Spring "cosa"
vogliamo, e lui lo realizza tramite i suoi algoritmi.
Spring Boot: Una versione "semplificata" di Spring che elimina la configurazione manuale noiosa tramite impostazioni
di default (auto-configuration), rendendo l'app pronta all'uso immediatamente.
Spring Initializr: Lo strumento (web o plugin IDE) per generare lo scheletro del progetto scegliendo dipendenze
(Lombok, Web, Data JPA, ecc.).
CONCETTO DI BEAN E CONTAINER
In Spring, non creiamo più manualmente gli "strumenti" del mestiere (come i DAO o i Service) nel main.
Bean: È un oggetto gestito da Spring. Sono "strumenti" (DAO, Faker, EntityManager), non dati volatili (non sono gli
utenti "Aldo, Giovanni e Giacomo").
Spring Container (ApplicationContext): Immaginalo come una "cassetta degli attrezzi". All'avvio dell'app,
Spring crea tutti i Bean necessari e li mette lì dentro.
Dependency Injection: Se un Bean A ha bisogno del Bean B (es. un Interviewer ha bisogno di uno Student), Spring vede
la dipendenza e "inietta" automaticamente l'oggetto richiesto.
COME ISTRUIRE SPRING
Sebbene esistesse l'XML, oggi usiamo le classi di configurazione Java:
@Configuration: Indica che la classe contiene le "istruzioni" per creare i Bean.
@Bean: Si mette sopra un metodo. Il valore restituito dal metodo diventa un Bean nel Container.
Gestione Ambiguità: Se abbiamo più Bean dello stesso tipo (es. tre tipi di Student):
@Primary: Indica a Spring quale scegliere di default in caso di dubbio.
Nome del Bean: Possiamo recuperare un Bean specifico per nome (di default è il nome del metodo).
BEAN SCOPE: SINGLETON E PROTOTYPE
Il comportamento (scope) dei Bean è fondamentale per la gestione della memoria:
Singleton (Default): Esiste una sola istanza in tutta l'app. Ogni getBean() restituisce lo stesso oggetto.
Per DAO, Service, Controller (oggetti senza stato interno variabile).
Attenzione al Singleton: se modifichi una proprietà di un Bean Singleton in un punto dell'app, quella modifica
sarà visibile ovunque, perché l'oggetto è lo stesso

Prototype: Viene creata una nuova istanza ogni volta che viene richiesto il Bean.
Per Oggetti che mantengono dati specifici per un'operazione e non devono essere condivisi.



@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@LEZIONE 2 Spring@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
in questa lezione continueremo con gli argomenti iniziati nella scorsa, nella scorsa lezione abbiamo parlato dei Bean,
della classe di configurazione, di cui ne faremo un rieppilogo e poi vedremo in questa lezione del terzo mettedo
annunciato nella scorsa lezione ovvero il 3° metodo per dichiarare i beans, o meglio per dichiararli e chiedere a
spring che crei degli oggetti che quella uttilizzata più di tutte, in più andremo a capire ulteriori caratteristiche
dei progetti spring, utilizzeremo uno specifico file di configurazione che sarà utile per la connessione al DB, non utilizzeremo
più il persistence XML, in favore di una cosa più semplice, e poi vedremo anche a livello teorico di altri benefici
dell'approccio spring in termine di codice scritto, perchè spring in base ai suoi principi ci aiuta a scrivere codice
fatto meglio.
STRUTTURA PROGETTO
la struttura del progetto ci permette di avere anche altre due parti importanti della nostra applicazione come ad esempio
la cartella Resources e anche test
La parte dei test sembra molto simile alla parte main ma in realtà è stata creata per la parte dei test dell'applicazione
che vedremo nella prossima lezione, invece in questa lezione vedremo la parte di resources
RESOURCES
Questa cartella resources con un solo file che è application.properties che contiene un'unica voce che è il nome del file per ora.
a è un file fondamentale per poter inserire delle informazioni per il nostro progetto dichiarandole con chiave valore.
ad esempio
postgress.url=jdbc:postgrsql://localhost:5432
postgress.username=postgres
postgress.password=1234
e abbiamo usato questo esempio per connettersi al db quindi non si userà più l'xml. inoltre il file applicatio.properties
viene usato come file da "lasciare segreto" perchè contenente password come per esempio l'apikey che sarebbe meglio mettere
qua. Però mettiamo il caso che io voglio recuperare una variabile dal application properties devo usare un'annotazione
@Value("${postgress.password}") ma non basta dovrò aggiungere anche @PropertySource("application.properties") per
leggere determinati valori perchè noi potremmo avere anche più file dentro la cartella resources
nel main abbiamo una anntazione @SpringBootApplication al cui interno abbiamo tante altre annotazioni una delle quali è
@ComponentScan questa annotazione permette, quando andremmo a creare dei componenti, all'avvio di controllare anche quei
componenti nuovi che andremmo a creare.
mettiamo che aggiungiamo nell'application.properties
admin.name= Claudio Bisio
se io volessi andare a leggere questo valore dalla classe di configurazione cosa devo fare devo creare un bean del tipo:
@Bean
public String getAdminName (String adminName) {
return adminName
}
se io runnassi così senza mettere ne @Value ne @PropertySource succederebbe che lui richiede una stringa e la stringa è
se stesso quindi una sorta di loop ma è un ERRORE, invece se runnassi solo con @Value così:
@Bean
public String getAdminName (@Value("admin.name")String adminName) {
return adminName
}
l'applicazione si avvierà ma non come vorremmo ma stamperà una cosa del genere:
FullstackStudent{} Student {name=admin.name , surname='Poretti'}
Perchè abbiamo inniettato la stringa "admin.name" nella dipendenza che cerca una stringa (@Bean
                                                                                          @Primary
                                                                                          public FullstackStudent getFSStudent(String name) {
                                                                                           return new FullstackStudent (name, "Poretti");
                                                                                          })
che verrà poi uttilizzata come nome del FullstackStudent e quindi quando stampiamo stamperemo admin.name poretti. invece
se mettessimo
@Bean
public String getAdminName (@Value("${admin.name}")String adminName) {
return adminName
}
e il sotto il @Configuration @PropertySource("application.properties") ecco che ora stamperà correttamente il campo con
FullstackStudent{} Student {name=Claudio Bisio , surname='Poretti'}.
questo è anche un trucco per poter leggere le application.properties con il @Value dato che nel main non si
può uttilizzare direttamente allora a questo punto con il getBean si potranno recuperare i valori del a.p
IoC & DI
Spring cerca di promuovere del codice fatto in una certa maniera, del codice che segue dei principi che portano a scrivere
codice fatto bene, quindi sarebbe bene, quando si programma, di fare in modo che il codice non funzioni solo oggi ma che
riesca a metterci le mani domani senza impazzire quindi ci sono dei principi architteturali che ci portano a fare le cose
fatte bene, questo porta tanti benefici anche in termini di test ad esempio, oppure n caso serva sostituire una parte di
funzionalità di codice con un'altra con facilità e senza impazzire, quindi il codice potrà funzionare bene ma non basta,
questo è possibile grazie all'Inversion of Control (IoC) e la Dependency Injection(DI). prima però bisogna capire il
LOOSE COUPLING (ACCOPPIAMENTO DEBOLE) e TIGHT COUPLING (ACCOPPIAMENTO FORTE), tra i due ciò che dobbiamo raggiungere
è il DEBOLE ciò vuol dire che ci sono elementi che si collegano tra di loro ma non si intersecano, invece nel TIGHT gli
elementi sono intersecati. l'accopiamento è quando due elementi hanno una dipendenza tra di loro, sono accoppiati, le
differenze stanno nel fatto che quello forte porta, in caso di modifiche, a dover cambiare il codice anche nelle altre,
come un'effetto domino, invece il LOOSE COUPLING dice le classi continuano a comunicare come hanno sempre fatto però
sono collegati in maniera debole, e ciò consente di modificare un elemento senza modificare gli altri o a sostituire
un'elemento senza sostituire gli altri, oppure testarne uno senza dover testare gli altri, magari facendo gli
altri 4 gli altri finti come magari in caso di dover testare gli ordini posso fare uno per pagamenti finti. quindi
sarebbe bene fare in modo che il cambiamento di un campo non deve / dovrebbe far cambiare gli altri. Mettiamo questo esempio:
public classs OrderProcessor {
  private PaymentGateaway paymentGateway = new PayPalGateway(); // accopiamento stretto
  public void processOrder(Order order) {
  // business logic
   paymentGateway.processPayment(order.getTotalAmount());
   }
}
vediamo in questo esempio dove abbiamo questa classe paymentGateway dove creiamo un'nuovo oggetto paymentGateway che
poi quando facciamo l'ordine verrà utilizzato processPayment, gli diamo il totale e fa il pagamento. Questo è un'esempio
di accoppiamento stretto perchè se un giorno decidiamo di cambiare paypal con un altra noi dovremmo andare a cambiare
anche la classe OrderProcessor e poi anche alle altre connesse con essa invace con questo esempio:

public interface PaymentGateway {
void processPayment(double amount);
}
public class PayPalGateway implements PaymentGateway {
public void processPayment(double amount); // implementazione specifica di Paypal
}
public classs OrderProcessor {
  private PaymentGateaway paymentGateway; // accopiamento debole
  public OrderProcessor(PaymentGateaway paymentGateway) {
  this.paymentGateway = paymentGateway;
  }
  public void processOrder(Order order) {
  // business logic
   paymentGateway.processPayment(order.getTotalAmount());
   }
}
in questo caso abbiamo PaymentGateway che è un interfaccia però in questo caso dipenderà dall'interfaccia, questo
vuoldire che dipende dall'interfaccia, e non c'è il new quindi non è la classe OrderProcessor a crearsi la dipendenza
bensì gli viene passato tramite parametro, da fuori. questo sembra una piccolezza ma fà davvero la differenza, e così
io posso aggiungere un'altro metodo di pagamento, dovrò fare semplicemente StripeGateway (chiamaiamo così la classe) che
implementa l'interfaccia PaymentGateway w gli potrò passare gli oggetti all'order all'OrderProcessor quindi posso
aggiungere  funzionalità di quel tipo senza toccare OrderProcessor una cosa del genere:
public class StripeGateway implements Payments PaymentGateway {
public void process Payment(double amount) {// implementazione specifica de Stripe
  }
}
public class orderProcessor{
  private StripeGateaway stripeGateway; // accopiamento debole
  public OrderProcessor(StripeGateaway stripeGateway) {
  this.stripeGateway = stripeGateway;
  }
}
questo ci permette di aggiungere anche molte nuove funzionalità di quel tipo senza toccare l'OrderProcessor, perchè dipende
interfaccia quindi dalle strazioni questo lascia delle porte aperte che ci evitano i vincoli dell'altro metodo. Invece qua
dipendiamo da un'interfaccia quindi con il polimorfismo riusciamo a passare più metodi di pagamento, in più non è OrderProcessor
a crearsi l'attributo ma gli viene passato da fuori quindi noi possiamo riutilizzare questo OrderProcessor con più metodi
di pagamento, potendo crearli anche in futuro senza dover rivedere tutta la classe OrderProcessor. Dunque parlando di classi
una regola importante è quella di evitare far creare all'interno della classe stessa, se ho già la classe a e ho bisogno
si oggetti della classe b non li creerò io ma li farò arrivare da fuori, ancora meglio sarebbe dipendere da classi astrate o
interfacce, perchè così mi lascio aperte delle porte. avremmo classi più indipendenti tra loro, OrderProcessor ha la minima
e indispensabile conoscenza degli altri moduli delle altre classi, quindi si influenzano poco a vicenda, anche avere poche
dipendenze dovrebbe essere un obbiettivo, e utilizzare interfacce o classi astratti è meglio che dipendere da implementazioni
concrete.
IoC è un principio di progettazione che si trova anche in frontEnd e nei software in generale. l'Inversion of Control
ovvero inversione di controllo vuol'dire che il flusso di programma e in particolar modo la creazione degli oggetti non
è più gestita dal programmatore ma bensì dal framework, come abbiamo già detto Spring crea e gestisce oggetti, gestisce
istanziazione, configurazione, lifecycle, e il fatto dell'accoppiamento debole più o meno lo abbiamo già visto nella
 scorsa lezione quando abbiamo scritto @Bean
                                       public Interviewer getInterviewer(Student, student) {
                                        return new Interviewer(student);
                                       }
perchè qua Interviewer non si sta creando la sua dipendenza ma gliela passiamo noi da fuori con student, e spring si
occuperà di innietare quella dipendenza quando deve creare l'oggetto Interviewer, ha il controllo, gestisce la dipendenza
cojn gli oggetti e innieta le dipendenze e da li la dependency injection(DI). Quindi questa IoC viene implementato a livello
pratico da ciò che viene detto DI la tecnica concreta che realizza l'IoC cioè una classe invece di crearsi le proprie
dipendenze con un setter o con un costruttore ad esempio come abbiamo fatto qua
@Bean
public Interviewer getInterviewer(Student, student) {
return new Interviewer(student);
}
io dichiaro un bean che ha bisogno di uno Student e lui va a cercarmi uno student questa è DI lui che va il cerca di un
qualcosa di compatibile.


COMPONENT E AUTOWIRED
il discorso appena fatto di IoC e Di si collegano con il discorso di COMPONENT E AUTOWIRED
I COMPONENT sono un concetto che ci permette di, sfruttando l'IoC, ovvero il controllo degli oggetti lo avrà sping, come
abbiamo fatto con i BEAN nella scorsa lezione, si può ottenere lo stesso risultato con i component.
L'AUTOWIRED invece vedremo che sarà una tecnica che serve per implementare la DI.
QUando pate l'applicazione spring c'è anche tutto il discorso di COMPONENTSCAN che viene effettuato, ovvero che all'avvio
rileverà se ci sono dei COMPONENT dunque se ci sono alcune classi che vengono annotate dall'annotazione component, in caso
venga rilevato succede che la classe verrà istanziata, quindi non servirà neanche fare una classe di configurazione, io ho
una classe la marchio come component e spring inizierà a istanziare una classe iniziando da quello, questo ci permetterà
di essere più veloci perchè non dovrò più fare come nella lezione passata:
@Bean
@Scope("prototype")
 public FrontendStudent getFEStudent() {
 return new frontendStudent("Aldo", "Baglio"); //SI NTENDE QUESTA PARTE
 }
ma semplicemente metterò l'annotazione sulla classe Interviewer, Student etc. questo però ha dei contro perchè io non
potrò più personalizzare questi oggetti in nessuna maniera, perchè è come una modalità fullautomatica, quindi non
utilizzeremo il Component quando richiedono della customizzazione nostra come nel @Bean che ho messo sopra, dove ho messo
dei valori  ("Aldo", "Baglio"), con l'approccio a component non potrò farlo,quindi quando uso @Configuration non è detto
io non debba usare anche l'altro, non è che sono rivali, però quando abbiamo bisogno della tipologia automatica utilizzeremo
l'approccio a Component mentre quando abbiamo bisogno di personalizzazioni in più, eseguire delle logiche. quindi l'approccio
a component si sposa bene in situazioni in cui dobbiamo  creare un'oggetto singleton e dove non c'è bisogno di tante
customizzazioni ma vogliamo avere nello scattolone come i dao.
I COMPONENT è  una classe che verrà istanziato all'avvio dell'applicazione. Spring cercherà inoltre di gestire l'inniezione
delle dipendenze quando creiamo questa classe perchè se questa classe ha delle dipendenze, perchè se questa classe ha
delle vuol'dire che per creare l'oggetto devo avere anche gli altri di dipendenze quindi lui si dedicherà a cercare
nello scattolone se ci sono gli altri li innieterà.

@Component
public class Book {
private String title;
private String author;

  public Book() {
     this.title= "Default Title"
     this.author= "Default author"
  }

  public String getTitle() {
   return title;
  }
  public String getAuthor() {
   return author;
  }
}
Ecco vediamolo su questo esempio, metto semplicemente @Component sopra la classe e lui creerà un oggetto di tipo book
con valori di default perchè è automatizzata perchè io non posso scegliere in fase di creazione di quali valori passargli
quindi non è che io posso passargli dei parametri e poi sceglierò io nella fase di creazione dell'oggetto cosa passargli
non usiamo il new, non usiamo noi il costruttore ma lo userà sping, quindi tra le parentesi qua public Book() o gli passo
le dipendenze che entrano nel giro del suoi BEAN altrimenti no, quindi potrò pure passargli due stringhe come parentesi ma
lo cercherà tra i bean quindi il limite sarà evidente. uno degli errori molto comuni è che se noi mettessimo un component
in un package che non è figlio del package principale tutto ciò non averrà.
Dunque quali sono le differenze tra Component e la classe di Configurazione?
si usa COMPONENT quando ho bisogno di componenti che devono essere creati in maniera autoattizata, invece
la classe di configurazione si userà quando avrò bisogno di tanta configurazione
Entrambi finiranno nello scattolone, per entrambi deleghiamo la creazione a spring e per entrambi lasciamo il controllo
su quegli oggetti QUINDI SONO BEAN IN ENTRAMBI LE SITUAZIONI, PERCHè UN BEAN è UN OGGETTO GESTITO DA SPRING, quindi la
classi di configurazione la userò quando ho bisogno di seguire delle logiche complesse quando uso component, quindi
sarebbe meglio usare la classe di configurazione in quel caso, apro le graffe e ci faccio quello che voglio, un'altra
un'altro punto a favore della classe di configurazione invece il fatto di dover creare i bean a partire da altre
librerie esterne come il FAKER, semplicemente per farlo dovrò fare un Bean del genere:
@Bean
public Faker getFaker() {
 return new Faker(Locale.ITALIAN)
}
 e così faccendo avrò il Faker in tutta l'app, nella pratica un altro punto dove ci serve il component sono i dao, oppure
 per ciò che vediamo più avanti sono i controller, i service e altri che vedremo più avanti invece qua invece di fare 10 DAO come
bean si mette component e i dao sono già pronti, negli esempi che abbiamo fatto fin ora un'component può essere l'interviewer
e per renderlo component dovrò @Componet sopra la classe e anche senza il bean nella config class ma solo con:
Interviewer i = ctx.getBean(Interviewer.class);
i.askQuestion();
il funzionerà tutto come prima, perchè quello che succede ora è che con component spring scansiona tutte le classi, vede
se ci sono delle classi, trova Interviewer crea l'oggetto interiviewer, quindi quando nel main lo richiediamo "Interviewer.class"
spring lo prenderà e prenderà lo studente Claudio Bisio perchè ha una dipendenza e tramite la DI, il componente è fatto così ora:
@Component
public class Interviewer{
private Student student
public Interviewer(Student student) {
   this.student = student
  }
}
quindi Interviewer con dipendenza Student vuol dire che prende il FullstackStudent che prende il bean getadminname()
che prende da Application.properties il valore admin.name="Claudio Bisio".
Quando abbiamo parlato di inniezione delle dipendenze, non avviene solo in un modo automatico come abbiamo visto ma
avviene anche grazie a eltre tre metodi. questi tre modi sono la CONSTRUCTOR INJECION che è quella che abbiamo appena
visto con student in Interviewer, dove noi dobbiamo solo passarlo e il resto avviene in maniera automatica, ma esistono
casi dove non vogliamo quel parametro lì come parametro del costruttore allora possiamo fare una SETTER INJECTION questa
userà il il setter su quella dipendenza e non avrà bisogno di un costruttore, quindi riuscirà a settare una dipendenza
tramite un setter. Oppure la FIELD INJECTION ovverò quella sugli attributi quindi non faccio ne costruttore ne Setter ma
metto direttamente un'attributo come dipendenza dunque se noi togliessimo il costruttore da Interviewer e mettessimo AUTOWIRED
funzionerebbe.
AUTOWIRED
autowired è un'annotazione che si occupa di richiedere in maniera esplicita a spring per favore innietami la dipendenza
facciamo un esempio di un setter:
public class OrderService{
 private PaymentGateaway paymentGateaway;

 @Autowired
 public void setPaymentGateaway(PaymentGateaway paymentGateaway) {
   this.paymentGateaway = paymentGateaway
 }
}
 questo non è molto comune ma serve nei casi dove non vogliamo avere un costruttore con quella dipendenza perchè magari
 l'oggetto e creato a mano in modo tradizionale, però quando usiamo Spring vogliamo che lo innieta la dipendenza. Ovviamemte
 il setter mi permette anche di modificare la dipendenza in un secondo momento.
il terzo caso che è il più semplice ma anche quello dove dovremmo fare più attenzione è quello in cui ho un'attributo
e basta e con @AUTOWIRED nell'attributo succede che la dipendenza viene innietata e funziona come se avessimo il
costruttore perchè richiedo a spring di innietare la dipendenza però questo è anche pericoloso perchè una classe con
troppe dipendenze è una BAD PRACTIES. Dunque ci saranno dei casi in cui i questo metodo sarà uttile perchè saranno inutili
i costruttori ma è sempre preferibile fare un costruttore quindi Constructor Injection.

PRYMARY & QUALIFIER
PRYMARY come abbiamo già visto è un'annotazione che serve per rendere di default un Bean nel caso di ambiguità varie, che
permetteràa di selezionare quel bean/component come "prescelto".
QUALIFIER invece fa una cosa molto simile am permette di selezionare tramite nome facciamo un esempio:

@Component("creditCardGateaway")
public class CreditCardGateaway implements PaymentGateaway{ // implementazione specifica di una carta di credito
}

@Component("paypalGateaway")
public class PaypalGateaway implements PaymentGateaway{ // implementazione specifica di paypal
}

// CLASSE OrderService

public class OrderService{
 private final PaymentGateaway paymentGateaway;

 @Autowired
 public OrderService(@Qualifier("creditCardGateway") PaymentGateaway paymentGateaway) {
   this.paymentGateaway = paymentGateaway;
 }
}

Quindi cosa succede qua quando creo due component e, se voglio, gli assegno un nome, poi metto nei parametri del
costruttore di OrderService l'annotazione @Qualifier con il nome e così gliela posso innietare.

COMMANDLINERUNNER
questa è una classe speciale che sfrutta le cose che abbiamo appena visto, che è utile in quei casi in cui abbiamo
bisogno di eseguire determinate logiche prima di avviare il main, ad esempio se volessimo riempire il DATABASE prima di
runnare il main il main viene eseguito prima e ci consente di fare una sorta di setup iniziale. questi runner devono
hanno delle caratteristiche fondamentali, devono avere le annotazioni @Component e devono implementare l'interfaccia
COMANDLINER, che ci farà fare l'@Override del metodo run. ada esempio:
@Component
public class MyCommandLineRunner implements CommandLineRunner {
  @Override
  public void run(String... args) throws Exception {
  S.o.p("L'applicazione è stata avviata con successo!")
  }
}

nel caso ci servisse posso avere anche più runner posso aggiungere l'ordine di running con l'annotazione @Order:

@Component
@Order(1)
public class MyCommandLineRunner implements CommandLineRunner {
  @Override
  public void r.........

@Component
@Order(2)
public class MyCommandLineRunner implements CommandLineRunner {
  @Override
  public void r...............

Oltretutto essendo dei Component è molto utile perchè si può implementare @Autowired con il faker ed essendo un component
quando verrà creato il faker verrà injectato dentro di lui senza doverlo leggere dal contest con getBean() e tutta quella
struttura

RIASSUNTO LEZIONE 2:
1. Configurazione e Gestione Resources
Il passaggio dai progetti Java standard a Spring comporta l'abbandono del file persistence.xml in favore di una
gestione più snella:
Cartella resources: Contiene il file application.properties, utilizzato per memorizzare coppie chiave-valore (es. URL
del database, username, password, API key).
Annotazioni chiave:
@PropertySource("application.properties"): Indica a Spring quale file caricare.
@Value("${chiave}"): Permette di iniettare il valore di una proprietà direttamente in una variabile o in un parametro
di un Bean.
@SpringBootApplication:
Include al suo interno @ComponentScan, che scansiona il progetto all'avvio per trovare e gestire automaticamente i componenti.
2. Accoppiamento e Principi IoC/DI
Spring promuove la scrittura di codice manutenibile e testabile attraverso due concetti fondamentali:
Accoppiamento (Coupling)
Tight Coupling (Forte): Le classi creano internamente le proprie dipendenze (es. new PayPalGateway()). Modificare una
classe costringe a modificare tutte quelle collegate (effetto domino).
Loose Coupling (Debole): Le classi dipendono da interfacce o astrazioni. Le dipendenze vengono fornite dall'esterno.
Inversion of Control (IoC) e Dependency Injection (DI)
IoC (Inversione del Controllo):
Il framework (Spring) assume il controllo del ciclo di vita degli oggetti. Non è più il programmatore a istanziarli con new.
DI (Dependency Injection): È la tecnica pratica con cui Spring "inietta" gli oggetti necessari (dipendenze) dentro le classi che li richiedono.
3. Dichiarazione dei Bean:
@Bean vs @ComponentEsistono due modi principali per far gestire un oggetto a Spring:
@Component:
Si mette sopra la classe. Spring la trova grazie alla scansione automatica e crea l'oggetto da solo. Si usa per le classi
del tuo progetto (DAO, Service) che non richiedono personalizzazioni particolari. È una modalità "automatica".
@Bean:
Si mette sopra un metodo in una classe di configurazione. Qui sei tu a scrivere il new e decidere come configurare
l'oggetto. È fondamentale per gestire librerie esterne (come Faker) o quando serve una logica complessa prima di
restituire l'oggetto.
4. Metodi di Iniezione e Risoluzione Ambiguità
Spring può iniettare dipendenze in tre modi:
Constructor Injection: Tramite il costruttore (consigliata, più sicura).
Setter Injection: Tramite metodi setter (annotati con @Autowired).
Field Injection: Direttamente sull'attributo della classe tramite @Autowired (rapida, ma meno pulita).
Gestione dei conflitti
Se esistono più Bean dello stesso tipo, Spring va in confusione. Si risolve con:
@Primary: Segna un Bean come preferito in caso di ambiguità.
@Qualifier("nomeBean"): Specifica esattamente quale Bean iniettare basandosi sul nome.
5. CommandLineRunner
È un'interfaccia speciale che permette di eseguire del codice subito dopo l'avvio dell'applicazione (es. per popolare
il database o loggare un messaggio di successo).
Deve essere annotata con @Component.
Implementa il metodo run(String... args).
Se ci sono più runner, si usa @Order(n) per stabilire la sequenza di esecuzione.


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@LEZIONE 3 RIPASSO E TEST@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

SALTATO RECUPERARE POI TODO


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@LEZIONE 4@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
In questa lezione vedremo la relazione con il DB che ci verrà facilitato dal jpa che ci farà tutto lui, direttamente
dallo spring initializer come per l'aggiunta di lombok attraverso le dependencies (Spring Data Jpa),(PostgreSQL Driver).
successivamente dovremo collegarci al database prima di tutto creiamo il progetto in pgAdmin, poi aggiungiamo in
spring.datasource.url=jdbc:postgresql://localhost5432/u5d4
spring.datasource.username=postgres
spring.datasource.password=1234
spring.datasource.driver-class-name=org.postgresql.Driver
spring.jpa.hibernate.ddl-auto=update
dopodichè runniamo per vedere gli errori e dopo se non ci sono errori andremo a creare le entities come sempre,
aggiungendo le varie annotazioniii  come @Entity, @Table successivamente i classici attributi, con
@Id
@GeneretedValue(strategy = GenerationType.IDENTITY) // incrementazione automatice di un numero seriale
@Column(name = profile_img" nullable = false) //non obbligatorio
successivamente costruttori getter e setter e i toString in caso non volessimo il setter sull'id
@Setter(AccessLevel.NONE) e lo stesso per il @Getter nella password. successivamente aggiungiamo una seconda classe "BlogPost" con
relazione
@ManyToOne
@JoinColumn(name = "author_id")
private User author
di BlogPost  mettiamo tutti gli attributi costruttore, getter e setter dei tostring e runniamo
dinuovo per vedere il DB. a questo punto serviranno i dao che saranno divisi in due parti grazie sia alle @Repository
che si occuperà di tutti i metodi base per interagire con la tabella, invece per la tutela del codice come eccezioni
ecceterà verrà utilizzata la classe service che si occupa di eseguire controlli eccezioni log, e anche service sarà un
component ma con annotazione @Service quindi la struttura adesso sarà per ogni tabella un service e una repository che
sostituiranno i nostri dao. inoltre la @Repository non è una classe ma un'interface che estende la
JpaRepository<classe entità di riferimento, tipo di dato dell'id>, questo è ciò che ci consentirà di creare tutto il CRUD
base come save, findById, findAll e possiamo aggiungere anche altri metodi custom come queries etc.
il prossimo passo del progetto è quello di creare un package delle repositories al cui interno aggiungeremo un interface
con annotazione @Repository ed extends JpaRepository<User, Long>, a questo punto possiamo aggiungere un runner per
vedere tutti i metodi che volevamo, iniziamo con implements ComandLineRunner{} al cui interno
private final UserRepository userRepository successivamente creiamo il costruttore con l'@Autowired e nel
@Override public void run  (String... args) throws Exception {} aggiungiamo il faker e un User con userRepository.save
dopo il print vedremo un user all'interno perchè aggiunto da noi .
successivamente andiamo a creare un package Service con all'interno una classe BlogService e servirà da intermediario
che serve per aggiungere ulteriori logiche controlli log etc. durante le interazioni con db,poichè i metodi nella repository
non ci sono. quindi ad esempio nelle repo si salva e basta mentre le service ci serve per controllare che l'email sia
unica, che la password rispetti determinati criteri anche ad esempio aggiungere un log di avvenuto salvattaggio può
essere fatta dal service o anche la gestione delle eccezioni custom è un dovere del service e non della repo. per esempio
per un metodo saveUser iniziamo aggiungendo il costruttore con l'@Autowired per per implementare le Repository all'interno.
successivamente si possono fare diversi passaggi come
1 contolla che l'email non sia già in uso
// TODO: si farà più avanti il check
if(usersRepository.existsByEmail(newUser.getEmail())) throw new ValidationException("Email" + newUser.getEmail() + " già esistente")
2 effettua altri controlli di validazioni sui dati inseriti
if (newUser.getName().length() < 2) throw new validationException ("il nome non può essere più corto di 2 caratteri")
3 aggiungi ulteriori dati server genereted
4 salvo effettivamente l'utente tramite repository
this.usersRepository.save(newUser);
5 log di avvenuto salvataggio: S.o.p("l'uttente è stato salvato correttamente " + newUser.getSurname());
dopo il save che abbiamo appena visto possiamo fare altri metodi come il findAll così:
public List<User> findAll() {
  return userRepository.findAll()
 }
}
poi possiamo aggiungere la findById che ha una particolarità ovvero l'optional che ci permette di gestire gli errori in
modo pulito, pulito perchè l'optional si presenta quando un qualcosa può esserci o no
lo faccioamo così così:
public User findById(long userId) {
 Optional<User> foundOrNot = usersRepository.findById(userId);
 if(foundOrNot.isPresent()) return foundOrNot.get();
 else throw new NotFoundException;
}
Oppure possiamo fare la stessa identica cosà con meno righe così:
public User findById(long userId{
return usersRepository.findById(userId).orElseThrow(() -> new NotFoundException(userId))
}


successiavamente possiamo aggiungere @Slf4j e anche un try catch nel runner per le eccezzioni di id doppi

 try {
   log.info(serService.findById(1).toString());
 }catch(NotFoundException ex){
   log.error(ex.getMessage());
 }

dopo possiamo, nel Service, fare dei metodi per modificare uno user questo lo possiamo fare così:

 public void findByIdAndUpdate (long userId, User update){
  //1 cerco l'utente tramite id
   User found = this.findById(userId);
  //2 aggiorno i campi di tale utente con quelli provenienti da updateUser
  found.setName(updatedUser.getName());
   found.setSurname(updatedUser.getSurname());
   found.setEmail(updatedUser.getEmail());

  //3 risalvo l'utente così modificato
  this.saveUser(found);

  //4 log.info
  log.info("l'utente" + found.getId() + "è stato modificato correttamente");
 }

e poi anche per eliminare uno user così:

 public void findByIdAndDeleted(long userId){
   User found = this.findById(userId); // questo perchè riutilizzo la findById per l'userId
   usersRepository.delete(found);
   log.info("L'utente" + found.getId() + "è stato cancellato"
 }

 e andiamo a testare questi nel Runner così:
  try {
    //log.info(serService.findById(1).toString());
    usersService.findByIdandDelete(1)
  }catch(NotFoundException ex){
    log.error(ex.getMessage());
  }
e runniamo se al primo run vediamo che nel db è sparito e nel secondo run vediamo che esce errore allora è andato tutto
correttamente, poi proviamo la findByIdAndUpdate così:
  try {
    //log.info(serService.findById(1).toString());
    //usersService.findByIdandDelete(1)
    usersService.findByIdAndUpdate(2, new User("aldo","baglio","aldo@gmail.com","Password1234") // la password non verrà modificata perchè ci vogliono delle procedure molto più articolate che vedremo
  }catch(NotFoundException ex){
    log.error(ex.getMessage());
  }

qiondi noi alla fine del Service avremmo una cosa del genere:

@Service
@Slf4j
public class UserService {
 private final UsersRepository usersRepository

  @Autowired
  public UsersService(UsersRepository usersRepository) {
   this.usersRepository= usersRepository;
  }

    public void saveUser(User newUser) {
      if (newUser.getName().length() < 2)
          throw new validationException ("il nome non può essere più corto di 2 caratteri")
      this.usersRepository.save(newUser);
      log.info("L'utente"è stato salvato correttamente " + newUser.getSurname());
    }

    public List<User> findAll() {
      return userRepository.findAll()
    }

    public User findById(long userId{
     return usersRepository.findById(userId).orElseThrow(() -> new NotFoundException(userId)
    }

    public void findByIdAndUpdate (long userId, User update){
     User found = this.findById(userId);
     found.setName(updatedUser.getName());
     found.setSurname(updatedUser.getSurname());
     found.setEmail(updatedUser.getEmail());
     this.saveUser(found);
     log.info("l'utente" + found.getId() + "è stato modificato correttamente");
    }

    public void findByIdAndDeleted(long userId){
     User found = this.findById(userId);
     usersRepository.delete(found);
     log.info("L'utente" + found.getId() + "è stato cancellato"
    }
}

Nel Service del Blog sara molto simile però con la differenza che nella save del User gli viene passato come parametro il
newUUser e viene salvato, in realtà il metodo posso farlo anche in altri modi mettendo il nome, cognome, email, password
nel senso che nella save del blog io potrei fare il metodo in questo modo:
@Service
@Slf4j
public class BlogsService{

 public void saveNewBlog(BlogPost newBlog){
 in questo caso useremo un parametro solo che contiene già tutto, però questo vorrebbe dire che uno fuosri dalla save
 dovrebbe andare a fare la findById dell'utente, passargliela al blog etc. come abbiamo fatto in UsersService
 }
  }

oppure possiamo fare una cosa del genere:
public class BlogsService{

  private final UsersService usersService;
  private final BlogsRepository blogsRepository;
  @Autowired
  public BlogsService (UsersService usersService, BlogsRepository blogsRepository) {
   this.usersService = usersService;
   this.blogsRepository = blogsRepository;
  }

 public void saveNewBlog(long UserId,String title, String content ){ // in questo caso gli viene passato l'id dello user
che si cercherà lui, il titolo e il content e farà tutto lui, però se devo fare una findById dell'utente io avrò bisogno
dello usersService e dei BlogsRepository da aggiungere sopra il metodo public void saveNewBlog, perchè è dalì che andremmo
a prendere i dati che ci servono e poi creiamo il costruttore con l'@Autowird.
1. A questo punto il primo passo sarà cercare l'autore con
User author = this.usersService.findById(userId); // questo sarà in grado di gestire anche gli errori perchè viene passato da usersService
2. a questo punto se troviamo l'utente creiamo l'oggetto BlogPost
BlogPost newBlog = new BlogPost(title, content, author);
3. successivamentefaccio la save
this.blogsRepository.save(newBlog);
4.un semplice log di avvenuto salvataggio
log.info("il blog è stato salvato correttamente" + newBlog.getTtle());
 }
}

Successivamente nel runner possiamo aggiungere l'attributo e nel costruttore il blogsService così:

private final BlogsServeìice blogsService;

public Runner(UsersService, BlogsService blogsService) {
   this.usersService = usersService;
   this.blogsService = blogsService;
}
@Override
public void run (String... args) throws Exception{
 Faker faker = new Faker(Locale.Italy);
 User user = new User(faker.name().firstname(), faker.name().lastname(), faker.email(), faker.password())

 try{
  //usersService.findByIdAndUpdate(1, new User("Aldo""baglio""Aldo@gmail.com""1234Password)
  e ora sarà possibile aggiungere anche un nuvo blog così:
    blogsService.saveNewBlog(1, "il titolo è Spring", "e spring è bello fa parte del content")
 }
 catch(NotFoundException ex ){
 log.error(ex.getMessage());}
 }
}

e possiamo mano a mano aggiungere anche tutti gli altri metodi nel service e testarli come abbiamo appena fatto come ad
esempio findAll:

public List<BlogPost> findAll() {
  return this.blogsRepository.findAll()
}


quindi il service del blog alla fine sarà una cosa del genere

@Service
@Slf4j
public class BlogsService{

  private final UsersService usersService;
  private final BlogsRepository blogsRepository;
  @Autowired
  public BlogsService (UsersService usersService, BlogsRepository blogsRepository) {
   this.usersService = usersService;
   this.blogsRepository = blogsRepository;
  }
 public void saveNewBlog(long UserId,String title, String content ){
  User author = this.usersService.findById(userId);
  BlogPost newBlog = new BlogPost(title, content, author);
  this.blogsRepository.save(newBlog);
  log.info("il blog è stato salvato correttamente" + newBlog.getTtle());

}

 public List<BlogPost> findAll() {
  return this.blogsRepository.findAll()
 }
}

QUERIES
per quanto riguarda le queries abbiamo diverse possibilità come il jql che abbiamo già visto funziona anche qua ma non
è l'unica possibilità perchè le due possibilità sono QUERY DERIVATE e QUERY CUSTOM CON JPQL o CON SQL NATIVO.
Nelle query derivate si scriverà molto meno codice ma non coprono tutti i casi quindi a volte sarà necessario farle custom
il posto adatto dove fare le query è nella REPOSITORY.
Per ripeterci le JPQL sono quelle SQL "ad oggetti" dove al posto di fare "SELECT * FROM users" nel jpql farò
"SELECT u FROM user u" con l'utilizzo della classe, oppure quando c'è di mezzo l'ereditarietà JPQL mi darà la possibilità
di scrivere le query in una sola maniera e far si che sia poi JPA a scegliere come convertirle in base a com'è la
strategia di ereditarietà che abbiamo deciso. e queste che abbiamo appena visto erano le QUERY CUSTOM CON JPQL o CON SQL NATIVO
QUERY DERIVATE
questo è il metodo più semplice per fare query con spring perchè si creano dei metodi in una certa maniera che grazie solo
al nome del metodo deriva la query. ad esempio findBy<NomeProprietà> come findBy<Name> o findBy<Surname> o findBy<Email>
questo è già come aver fatto la query di selezione ad esempio:

@Repository
public interface UsersRepository extends JpaRepository<User, Long>{
 List<User> findBySurname(String surname);
 questa è la queri e corrisponderà a "SELECT * FROM users WHERE surname = :surname"
 ma inoltre possiamo usare anche operatori logici come Or And Not così:
 List<User> findByNameAndSurname(String name, String surname);
 e questa corrisponde a "SELECT * FROM users WHERE name = :name AND surname = :surname"
}
ci sono anche altre cose molto interessanti oltre che agli operatori logici come "findByPrezzoLessThan(double prezzo)":
che cercherà un entità con un prezzo inferiore di un valore, ci sono anche GraterThan, GraterThanEqual e LessThanEqual,
ma abbiamo anche gli OrderBy tipo findByCategoriaOrderByPrezzoAsc(Categoria categoria): che cerca entità di una determinata
categoria e le ordina per prezzo in ordine ascendente,
oppure abbiamo anche  findByFirstByCategoria: che mi torna solo il primo risultato della lista
oppure abbiamo anche  findByNomeNot: che mi torna i nomi che non si chiamano in un determinato modo
oppure abbiamo anche  findByNomeLike: che mi torna i nomi che contengono una determinata parte
oppure abbiamo anche  findByNomeIgnoreCase: che mi torna i nomi indipendentemente da maiuscole o minuscole
etc etc
ma ci sono dei contro perchè come abbiamo già detto non coprono tutti casi che ci servono, anche in casi particolari come
l'extract from non c'è quindi tocca customizzare

QUINDI ALLA FINE LA REPOSITORY SARà UNA COSA DEL GENERE
@Repository
public interface UsersRepository extends JpaRepository<User, Long> {
 List<User> findBySurname(String surname);
  List<User> findByNameAndSurname(String name, String surname);
}


 e poi nel USERSERVICE lo possiamo riportare con il nome :

public List<User> filterBySurname(String surname) {
  return usersRepository.findBySurname(suname)
}
public List<User> filterByNameAndSurname(String name, String surname) {
  return usersRepository.findByNameAndSurname(name, surname)
}
public List<User> filterByNameStartsWith(String partialName) {
  return usersRepository.findByNameStartsWithIgnoreCase(partialName)
}

e poi nel RUNNER LO POSSIAMO USARE COSì:

usersService.filterBySurname("Baglio").forEach(S.o::println);
E STAMPERà LA LISTA DI QUELLI TROVATI

usersService.filterByNameAndSurname("Aldo", "Baglio").forEach(S.o::println);
E STAMPERà LA LISTA DI QUELLI TROVATI

usersService.filterByNameStartsWith("b").forEach(S.o::println);
E STAMPERà LA LISTA DI QUELLI TROVATI

ma abbiamo anche un'altro modo di fare le query nella repository che è con il boolean grazie a existsBy ad esempio:

boolean existsByEmail(String email); che non mi torna ne una lista ne un'utente ma semplicemente true o false.

ma abbiamo anche le native in due modi:
@Query("SELECT u FROM User WHERE u.name = :name")
List<User> filterByName(String name);
oppure:
@Query(nativeQuery = true, value= "SELECT u FROM User WHERE u.name = :name")
List<User> filterByName(String name);

quindi alla fine della fiera possiamo fare la "validazione" della mail del save con: Riga 766

RIASSUNTO:
Gemini said
In questa lezione viene spiegata l'integrazione tra un'applicazione Spring Boot e un database PostgreSQL attraverso l'utilizzo di Spring Data JPA. Il processo inizia con la configurazione del progetto tramite Spring Initializr, aggiungendo le dipendenze necessarie come Lombok, Spring Data JPA e il driver di PostgreSQL. La connessione al database viene stabilita configurando il file delle proprietà dell'applicazione con i parametri relativi all'URL della sorgente dati, le credenziali di accesso e la strategia di Hibernate per l'aggiornamento automatico dello schema.

La struttura del progetto segue il modello delle entità, dove le classi Java vengono mappate sulle tabelle del database
utilizzando annotazioni specifiche come @Entity e @Table. All'interno delle classi si definisce la chiave primaria con
@Id e se ne imposta la generazione automatica. Per gestire correttamente i dati e la sicurezza, si utilizzano le
annotazioni di Lombok per generare costruttori, getter e setter, avendo cura di limitare l'accesso ai metodi di modifica
per campi sensibili come l'ID o la password. Viene inoltre mostrata la gestione delle relazioni tra tabelle, ad esempio
una relazione MANY-TO-ONE tra un post di un blog e il suo autore, definita tramite @ManyToOne e @JoinColumn.

Il cuore dell'interazione con i dati è rappresentato dalle Repository e dai Service. Le Repository sono interfacce che
estendono JpaRepository e forniscono automaticamente tutti i metodi per le operazioni CRUD di base. I Service, invece,
fungono da intermediari logici tra le Repository e il resto dell'applicazione. All'interno dei Service vengono
implementati i controlli di validazione, la gestione delle eccezioni personalizzate e i log delle operazioni. Ad esempio,
prima di salvare un nuovo utente, il Service verifica la lunghezza del nome o l'unicità dell'email, lanciando eccezioni
specifiche in caso di errore. I metodi del Service coprono tutte le necessità operative: la ricerca per ID con gestione
degli Optional, il recupero di tutti i record, l'aggiornamento dei campi e la cancellazione.

Un aspetto fondamentale riguarda la possibilità di creare query personalizzate. Oltre ai metodi standard, è possibile
definire le cosiddette "Query Derivate" semplicemente seguendo una convenzione di denominazione dei metodi
nell'interfaccia Repository. Spring è in grado di interpretare nomi come findBySurname o findByNameAndSurname per
generare automaticamente il codice SQL corrispondente. Esistono inoltre operatori per ricerche più complesse, come il
filtraggio per valori inferiori o superiori, l'ordinamento e la ricerca di corrispondenze parziali ignorando le maiuscole.
Quando le query derivate non sono sufficienti, si può ricorrere a JPQL o SQL nativo per una personalizzazione totale.
Infine, l'utilizzo di un Runner consente di testare concretamente il funzionamento dell'applicazione, simulando
l'inserimento di dati tramite librerie come Faker e verificando la corretta persistenza e manipolazione delle
informazioni sul database.