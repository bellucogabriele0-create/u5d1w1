@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@LEZIONE 1 Spring INTRO@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
spring è il nostro framework di riferimento
per poter capire come scrivere del codice per del web server allora sarà essenziale capire come funziona spring.
Spring ci consente di automattizzare tutti quei passaggi dove c'è una richiesta,leggerne il contenuto,
interpretarlo, fornirci oggetti e poi darci delle risposte e può farne anche più di una di queste azioni alla volta
e questo permetterà a noi di focalizzarci sulla business logic ovvero ciò che deve davvero fare l'app delegando le cose
ripetitive a spring anche per esempio alle cose relattive alla sicurezza dell'app ci possiamo servire di spring security
anche per il discorso della manipolazione dei dati dal db usufruiremo di spring. Parlando di una delle cose più
ricorrenti che un programmatore deve fare è quella di creare oggetti come per esempio nell'ultima buildweek abbiamo
fatto circa 10 dao e nel main di conseguenza neabbiamo dovuti creare altre tanti, e se gli stessi dao servissero anche
in altri punti dell'app allora li dovremmo rifarne altre tanti quindindi diventerebbe un bel lavorone ripettitivo,
inoltre le app che abbiamo fatto fin ora, vivono solo nel main ma la verità è che la logica viene utilizzata in più
e più parti, quindi quello stesso dao avrei bisogno di usarlo in più parti, ecco che qua ci viene in soccorso Spring
che creerà oggetti per noi quindi io delego questo compito a spring, io prima creo i dao come classe e gli oggetti
glieli lascio creare a lui pronti all'avvio, attenzione però lui non mi andrà a creare l'user aldo giovanni e giacomo etc.
no si intende quegli oggetti che sono strumenti come i dao o come il faker per esempio, oppure poter rendere disponibile
il dao senza dover istanzire più volte un'oggetto grazie a un'annotazione che ci consentirà di renderlo diponibile
in tutta l'applicazione e questo ragionamento dei dao si potrà applicare a tante altre classi.
quindi con un approccio dichiarattivo io gli dico cosa voglio e spring dietro ha una serie di algoritmi che producono il
risultato ovvero la creazione di quegli strumenti citati prima, ma saprà creare oggetti non solo prima dell'avvio
dell'app ma anche durante l'esecuzione come per esempio quando abbiamo un web server e mi arriverà una richiesta
spring creerà un'oggetto per quella richiesta e me lo metterà a disposizione in maniera tale che io riesca a leggere
quello che c'è nel payload negli headers e quindi noi saremo in grado di accedere alla richiesta http e in una
maniera simile saremo in grado di capire come lui riesce a creare delle risposte, anche l'entityManager e factory
verranno fatti da spring e non da noi.
SPRING BOOT
Spring boot e spring sono correlati ma non sono la stessa cosa che ci permetterà di scrivere ancora meno codice, perchè
spring necessita di una sorta di settaggio per essere uttilizzato invece spring boot ci evita tutta questa parte creando
una sorta di default che vada bene in generale sempre sovrascrivibile ma già pronto ad essere visualizzato (un po come i
colori primary danger secondary warning di react).
Per iniziare un progetto spring esistono due metodi da browser o da intellij ma saranno identici a differenza che da
intellij servirà un plugin, per fare ciò da browser andiamo su Spring initialzr, e configuriamo le scelte che ci servono
ovvero:  maven / java / 4.0.2 / gropu:gabrielebelluco / artefact: u5d1w1 / pack jar / config : Properties/ Java : 21
e nelle dependencies possiamo scegliere dei pacchetti da aggiungere come spring web, spring data, postgres, lombok,
security e altri successivamente facciamo generate e ci scaricherà uno .zip che dovremo aprire con intellij.
invece da intellij con il plugin è con "start spring booot project" e i passaggi saranno identici al browser.
BEANS
tutta la parte di delegazione degli oggetti parte dai beans i beans sono degli oggetti gestiti da spring come i
dao, ma ci sono anche altri esempi come abbiamo già detto, come le richieste http che sono rappresentate da un oggetto
che noi esploreremo, ne leggiamo il contenuto, quindi immaginiamoci un'oggetto di una certa classe che conterrà la
richiesta che è appena arrivata e chi crea quell'oggetto/Strummetno è spring e noi lo utilizziamo. stessa cosa per i dao
prendiamo tutti i dao di cui abbiamo bisogno e diaciamo a spring, spring all'avvio li crea e li mette in una sorta di
scattolone (CONTAINER) in cui all'interno ci saranno tutti questi oggetti e noi prendiamo quello che ci serve, e la
cosa interessante è che spring ad es. per i dao non creerà moltecipli oggetti ma ne creerà uno solo utilizzabile in
tutta l'applicazione, perchè un dao è semplicemente un oggetto con dei metodi quindi non è che deve essere diverso ogni
volta che lo utilizzamo.
Spring Container
quello che abbiamo chiamato contenitore prima in realtà ha più nomi, ma in generale è chiamato Container e in spring
abbiamo due nomi principali BeanFactory e l'ApplicationContext(che è quello utilizzato da noi perchè è funzionale).
quindi immaginiamoci come se in una parte dell'applicazione troviamo questo container chiamato Spring Application Context
con all'interno tutti i beans all'interno. Quando noi scriviamo il codice decidiamo quali classi far gestire a spring
e quali no e tutte le classi che noi scegliamo di far gestire a Spring all'avvio dell'applicazione crea lo scattolone
e ci mette tutti i beans/oggetti all'interno (un po come la cassetta degli attrezzi detta prima con all'interno tutti i
dao già pronta) e non importerà se noi siamo nel main o in qualsiasi altro punto noi potremmo accedere
all'applicationcontext e prendere gli oggetti che ci servono. e il nostro compito sarà quello di capire come fare a
mettere dentro il context ciò che noi vogliamo metterci all'interno e dare le istruzioni per poter sfruttare gli oggetti,
e per fare ciò ci sono diversi metodi, invece gli altri oggetti creati da noi saranno oggetti classici creati da noi e
saranno fuori dal context. ci sono 3 diverse strade per istruire spring:
1 dichiarazione xml: (non più utilizzato)
2 Configurazione basata su Java: (utilizzato grazie a @Configuration @bean)
3 Configurazione basata su annotazioni ()
Noi utilizzeremo un' approccio dichiarattivo noi dichiariamo cosa vogliamo e lui realizzerà cio che vogliamo.
XML
la dichiarazione con xml avrà una struttura del genere:
<beans> qui ci andrà tutta l'intestazione
  <bean (qui ci andrà l'id) id="personBean" (qui ci andrà la classe a qui ci riferiamo ) class="com.example.Person" >
    <property (e qui gli attributi per il suo costruttore) name="name" value="don joe"/>
    <property name="age" value="30"/>
  </beans>
</beans>
logicamente all'interno si possono creare anche più bean basta aggiungerli all'interno del "beans" ma possono essere
anche collegati tra di loro grazie all'autowire
  <bean id="orderBean" class="com.example.Order" autowire="byType" >
quindi questo gli consentirà di creare anche oggetti complessi perchè avrà una dipendenza verso un'altro.
Quindi una volta creati i Bean li leggiamo dall'ApplicationContext, ci sono più modi per leggerli dal context
2 CONFIGURAZIONE BASATA SU JAVA:
questo approccò farà le stesse cose ma con java quindi ci permetterà di scrivere codice controllato da intellij, o
aggiungere anche logiche come funzioni cicli, essa però prevede la creazione di una classe che si chiamerà classe di
configurazione al cui interno metteremo dei metodi i quali mi torneranno dei bean quindi all'interno metterò delle
istruzioni che spiegerà a spring come crearmi quel particolare bean, notiamo che nel'immagine ci sono due
annotazioni principali esse sono @Configuration e @Bean.
@Configuration si mette a livello di classe non di metodo per far capire a spring che questa è una classe di
configuration altrimenti sarebbe una classe come un'altra
@Bean si mette a livello di metodo e se ne mettiamo più di uno dovremmo metterlo a ognuna altrimenti viene ignorato.
con una struttura come questa:
@Bean
pulblic Person personBean () {
     Person person = new person();
     person.setName("don Joe");
     person.setAge(30);
     Return person;
}
quindi le graffe che vediamo qua ci consentiranno di creare anche della logica molto complessa l'importante è che ci
ritorni person come abbiamo qua, allo stesso modo posso far tornare liste, stringhe, numeri, array quello che voglio
quindi non solo l'oggetto singolo come in questo caso ma anche cose più semplici o più complesse.
Un altro caso è questo:
@Bean
public Customer customerBean() {
    Person person = new person();
    person.setName("don Joe");
    return customer;
}

@Bean
public Order orderBean(Customer customer){
return new Order (customer)
}
qua creiamo una dipendenza perchè gli stiamo dicendo che per creare il bean di tipo Order deve creare un bean di
tipo Customere dentro le graffe gli diremo come si creeranno gli ordini e l'ordine ha un parametro customer che deriva
dallo stesso parametro del metodo, però come farà a capire chi scegliere come customer? ciò che succede dietro le quinte
è che spring rileva la classe di configurazione, sceglie i metodi con i @bean poi li mette nel container,
successiavamente prende quelli con dipendenze e controlla quali hanno lo stesso nome delle dipendenze, prende in questo
caso il customer e glielo passa. quindi a questo punto abbiamo dato istruzioni per creare gli oggetti usare il metodo
crearlo e meterlo dentro il container per poterlo mettere a disposizione, a disposizione dell'applicationContext ctx
per poter accedere a quegli oggetti e poi possiamo prendere gli oggetti di tipo person, customer, order etc.
dunque facciamo degli esempi, creiamo una cartella entities con una classe padre e student e più classi figlie BackendStudent
FrontendStudent e FullstackStudent
 quindi creiamo una classe astratta padre Student
public abstract class Student {
    @Setter(AccessLevel.NONE) // Serve per eliminare il setter automatico su un campo specifico
 	private UUID id;
	private String name;
	private String surname;

	public abstract void answerQuestion(); // che ci darà un S.o.p diverso l'uno dall'altro
}
nelle classi figlie invece creiamo il costruttore delle con il super,il toString e l'Override del answerQuestion così:
	@Override
	public void answerQuestion() {
		System.out.println("Ciao sono lo studente BACKEND e la risposta alla domanda è...blablbalba");
	}
	@Override
	public String toString() {
		return "BackendStudent{} " + super.toString();
	}
aggiungiamo anche una classe config nel package config che è una classe "speciale " all'interno dell'applicazione.
Essendo annotata da @Config, questo significa che al suo interno potremo inserire N metodi, ognuno dei quali conterrà
le "istruzioni" per generare un Bean, ovvero per chiedere Spring di gestire lui quell'oggetti ed inserirlo
nell'application Context (lo "scattolone"), per creare un nuovo @Bean aggingiamo un metodo con annotazioni @Bean per
esempio
@Bean
public int getNumber() {
  return 42;
  }

  @Bean
  public String getAdminName() {
  return "ajeje";
  }
 @Bean public FrontendStudent getFEStudent() {
 return new frontendStudent("Aldo", "Baglio");
 }
@Bean public backendStudent getBEStudent(){
return new BackendStudent ("Giovanni", "Storti")
}
@Bean
public FullstackStudent getFSStudent() {
 return new FullstackStudent ("Giacomo", "Poretti");
}

e ora nel main andiamo a scrivere la lettura BEANS da CONTEXT, seguendo questi passaggi:
1.Ottengo un riferimento al context
2. Tramite metodi .getBean dell'oggetto context possso leggere i bean dallo scattolone e posso usarlicome oggetti normalissimi
1. =
AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(U5d1w1Application.class);
all'interno delle tonde si da la classe di riferimento che viene passata al costruttore "AnnotationConfigApplicationContext"
e poi lui mi torna un'oggetto ctx. Infatti adesso nel passaggio 2. se scriviamo ctx.getBean abbiamo due modalità di
recuperare il bean attraverso la prima è tramite nome e l'altra è tramite classe la differenza sta nel tipo di ritorno
se uttilizzo tramite nome mi torna un'object generico il quale poi dovrò fare un cast, invece l'altra è passando il tipo
della classe lui me la tipizzerà già con il tipo giusto
_
FrontendStudent fes = ctx.getBean(frontendStudent.class);
S.o.p(fes);
_
e questo nel terminale mi stamperà: FrontendStudent{} Student {name='Aldo' , surname='Baglio'}

oppure possiamo fare anche: fes.answerQuestion
questo per far capire che dunque diventa un'oggetto utilizzabile. quindi fin'ora nel main non abbiamo mai creato
oggetti nel main questo perchè viene auto generato da spring messo dentro ctx e poi da ctx posso estrarre ciò che serve
in caso avessimo più oggetti dello stesso tipo potremo avere dei problemi di ambiguità, allora lì entra in gioco il discorso
del nome come abbiamo detto prima i bean possono essere letti per nome, e per ciò c'è una ragione, inanzitutto il nome
del bean se non specificato in un altro modo è il nome del metodo in questo caso ad esempio è "getFEStudent()"  e nel
main scriveremo FrontendStudent fes2 = ctxgetBean("getFEStudent"); il problema qua è che lui mi tornerà un object quindi
bisognerà castare altrimenti FrontendStudent fes2 = ctx.getBean("getFEStudent", FrontendStudent.class); e qua il
risultato è sempre lo stesso dunque
FrontendStudent{} Student {name='Aldo' , surname='Baglio'}  Ciao sono lo studente BACKEND e la risposta alla domanda è...blablbalba
oppure possiamo specificare il nome direttamente al bean così:
 @Bean(name= "aldo")
 public FrontendStudent getFEStudent() {
 return new frontendStudent("Aldo", "Baglio");
 }
dunque opzionalmente posso nominare un bean, altrimenti verrà utilizzato il nome del metodo.
ora mettiamo il caso che il bean in ConfigClass abbia un parametro del tipo:
@Bean
public FullstackStudent getFSStudent(String name) {
 return new FullstackStudent (name, "Poretti");
}
a questo punto nel main se noi creassimo un oggetto del tipo :
FullstackStudent fss = ctx.getBean(FullstackStudent.class);
S.o.p(fss);
nel terminale ci stamperà
FullstackStudent{} Student {name='Ajeje' , surname='Poretti'}
questo perchè prima ho definito un bean di tipo stringa che mi torna ajeje riga 146 che gli abbiamo passato come parametro
quindi lui la cercherà nello scattolone e se lo trova lo passa altrimenti darà un'errore. invece se ci fosserò più di un
bean di tipo String noi dobbiamo essere chiari con quale dei due vogliamo passare
 @Bean
 public String getAdminName2() {
 return "Claudio"
 }
 ma lo vediamo meglio dopo e ciò che
abbiamo fatto passando il parametro è chiamata DIPENDENZA.
ora per rendere più chiaro il concetto ci creiamo un'altra entity di nome Interviewer e gli passiamo come attributo Student
in modo da poter fare i colloqui a tutti gli studenti, in questo modo:
public class Interviewer {
  private Student student;

  public Interviewer (Student student) {
  this.student = student;
  }
  public void askQuestion() {
  S.o.p("Ciao "+ student.getName() + ", rispondi alla seguente domanda.... #####"
  this.student.answerQuestion();
  }
}
quindi con questo esempio vediamo che c'è una connessione tra una classe e un'altra, tra interviewer e student e anche
questa è una dipendenza  e significa che quando creiamo un'interviewer deve esistere già uno studente non può essere
creato dopo lo studente, un po come le relazioni tra le varie tabelle, ad esempio non posso creare l'abbonamente se
non c'è l'utente. Dunque cosa succede se io creo un bean di tipo Interviewer nella ConfigClass? del tipo:
@Bean
public Interviewer getInterviewer(FullstackStudent, student) {
 return new Interviewer(student);
}
questo esempio è molto simile a quello creato nel bean dove passavamo String name. dunque per testare andiamo nel main
e creiamo Interviewer nello scattolone in questo modo:
Interviewer i = ctx.getBean(Interviewer.class);
i.askQuestion();
e ciò stamperà:
 Ciao Claudio, rispondimi allaseguente domanda...#####
 Ciao sono lo studente FULLSTACK e la risposta alla domanda è....blablabla
ciò che succede nella console è che Interviewer grazie a @Bean viene creato come oggetto, prende uno student,
ma prende quello  indicato dal tipo "FullstackStudent", ne abbiamo solo uno che prende il nome da getAdmin2
(getInterviewer<getFSStudent<getAdmin2)
quindi un'altra delle cose importanti di spring è che non solo crea oggetti ma riesce anche a collegarli uno all'altro
dunque in questo ultimo esempio noi avremmo il parametro Student che è una dipendenza del Bean Interviewer.
ora facciamo l'esempio che invece di passare FullstackStudent passiamo Student così:
@Bean
public Interviewer getInterviewer(Student, student) {
 return new Interviewer(student);
}
ecco che quà ci darà un errore perchè troverà tre studenti (Aldo, getBEStudent,getFSStudent) perchè c'è di mezzo il
polimorfismo, QUINDI è MEGLIO EVITARE.
RICAPITOLANDO ciò che possiamo riassumere da quanto visto fin'ora è che possiamo creare dei bean nella classe di
configurazione quindi riempire il container (scattolone) estrarrli quando abbiamo bisogno di utilizzarli con il get bean
però ci sono tutte quelle dinamiche da tenere in considerazione nel senso non possiamo dichiarare dei bean uguali e
pretendere che attraverso il tipo lui riesca a capire come distinguerli, non possiamo non dichiarare un bean che è
necessario per un'altro bean, mancanze, se ci manca il FullstackStudent ci da errore, in caso di parametro errato ci
da errore perchè trova 3 risultati, e per questo il primary è una delle annotazioni che si possono dare per evvitare
che si cada nell'errore, nel senso che mettendo come in questo caso ci sono tre Student e ne mettiamo uno come @Primary
risolverò l'ambiguità in questo modo:
@Bean
@Primary
public FullstackStudent getFSStudent(String name) {
 return new FullstackStudent (name, "Poretti");
}
Dunque l'annotazione primary dice in caso di ambiguità preferisci lui, come se fosse una sorta di default.
BEAN SCOPE
cosa è uno scope? lo scope determina il comportamento di questi bean.
 IL SINGLETON: significa che quando all'interno di un'applicazione viene creato un'oggetto, quell'oggetto è unico singolo
l'unica coppia che esiste all'interno di quell'applicazione è quello il primo ad essere creato, ulteriori tentativi di
creazione falliscono o verrà restituito sempre lo stesso oggetto, sempre la stessa locazione di memoria, quindi di default
tutti i bean sono Singleton, infatti quando abbiamo creato i due oggetti identici fes e fes2 in realtà sono lo stesso
essendo singleton, a meno di non cambiare lo scope da singleton a qualcos'altro. questa caratteristica del singleton è
molto  importante perchè quando abbiamo ad esempio i DAO non ha senso crearsi gli oggetti DAo ogni volta che li richiedo,
ne basterà uno per tutta l'applicazione, quindi il fattore che siano singleton mi crea il dao e ogni volta che devo usare
il dao non è che lo ricrea mi da sempre un riferimento allo stesso oggetto perchè non ha senso crearne una copia e sarebbe
anche uno sprecco di spazio, ciò avrà anche dei contro nel senso che se avessimo dei setter in un esempio del genere:
FrontendStudent fes = ctx.getBean( FrontendStudent.class);
S.o.p(fes);
fes.setName("Mario");
FrontendStudent fes2 = ctxgetBean("getFEStudent", FrontendStudent.class)
S.o.p(fes2);
succederà questo, primo passaggio: estraggo il bean FrontendStudent dallo scattolone che si chiama "Aldo"-> stampo e in
console avrò FrontendStudent{} Student {name='Aldo' , surname='Baglio'} -> setto il nome a "Mario" -> estraggo dinuovo
il nome con il getBean dallo scattolone aldo ma non è più aldo è Mario questo per far capire che sono entrambi un'oggetto
solo ma ricchiamato più volte in modi diversi. questo può essere cambiato ma non è detto che ci sia utile, ad esempio
scope PROTOTYPE è L'OPPOSTO di Singleton cioè ogni volta che faccio getbean mi viene creato una coppia dell'oggetto
dunque a meno che non sia necessario è meglio singleton ad esempio
@Bean
@Scope("prototype")
 public FrontendStudent getFEStudent() {
 return new frontendStudent("Aldo", "Baglio");
 }
questo farà in modo che stamperà
FrontendStudent{} Student {name='Aldo' , surname='Baglio'}
FrontendStudent{} Student {name='Aldo' , surname='Baglio'}
percè nel primo passaggio ora è aldo ma non ristampiamo dopo il settaggio del nome e nel secondo stampiamo aldo però essendo
PROTOTYPE creerà un'altro oggetto aldo baglio.
quindi scope è un'annotazione opzionale se non è specificato è singleton di default,
SINGLETON:in tutta l'applicazione esiste un'unica coppia dell'oggetto. Ogni volta che faccio getBean() mi torna sempre
stesso oggetto
PROTOTYPE: ogni volta che uso getBean mi torna una nuova copia dell'oggetto.
LOMBOK:
è uno strummento da non uttilizzare in azienda ma utile per prototipi o codice di prova quando questo ci aiuta con le
varie annotazioni a creare per esempio
@Data: crea equals, getter e setter, toString, hashCode per tutti i campi della classe
@Getter, @Setter : generano i getter e setter
@NoArgsConstructor e @AllArgsConstructor: Generano costruttori sia vuoto che pieno
@ToString: genera un metodo toString per la classe (problemi di bidirezionalità)
@EqualsAndHashCode: genera metodi equals e hashCode per la classe.
@Builder: fornisce un modello di progettazione del tipo Builder per creare oggetti immutabili in modo fluente.
Nel caso in cui noi volessimo non settare l'UUID come molto spesso capita, dobbiamo mettere sopra il campo desiderato
per esempio @Setter(AccessLevel.NONE)

RIASSUNTO
Spring è il framework di riferimento per lo sviluppo Java. Il suo scopo principale è automatizzare i compiti ripetitivi
(gestione richieste HTTP, sicurezza, connessione al database) per permettere allo sviluppatore di concentrarsi solo sulla Business Logic.
Approccio Dichiarativo: Non scriviamo noi il "come" fare le cose (es. istanziare oggetti), ma diciamo a Spring "cosa"
vogliamo, e lui lo realizza tramite i suoi algoritmi.
Spring Boot: Una versione "semplificata" di Spring che elimina la configurazione manuale noiosa tramite impostazioni
di default (auto-configuration), rendendo l'app pronta all'uso immediatamente.
Spring Initializr: Lo strumento (web o plugin IDE) per generare lo scheletro del progetto scegliendo dipendenze
(Lombok, Web, Data JPA, ecc.).
CONCETTO DI BEAN E CONTAINER
In Spring, non creiamo più manualmente gli "strumenti" del mestiere (come i DAO o i Service) nel main.
Bean: È un oggetto gestito da Spring. Sono "strumenti" (DAO, Faker, EntityManager), non dati volatili (non sono gli
utenti "Aldo, Giovanni e Giacomo").
Spring Container (ApplicationContext): Immaginalo come una "cassetta degli attrezzi". All'avvio dell'app,
Spring crea tutti i Bean necessari e li mette lì dentro.
Dependency Injection: Se un Bean A ha bisogno del Bean B (es. un Interviewer ha bisogno di uno Student), Spring vede
la dipendenza e "inietta" automaticamente l'oggetto richiesto.
COME ISTRUIRE SPRING
Sebbene esistesse l'XML, oggi usiamo le classi di configurazione Java:
@Configuration: Indica che la classe contiene le "istruzioni" per creare i Bean.
@Bean: Si mette sopra un metodo. Il valore restituito dal metodo diventa un Bean nel Container.
Gestione Ambiguità: Se abbiamo più Bean dello stesso tipo (es. tre tipi di Student):
@Primary: Indica a Spring quale scegliere di default in caso di dubbio.
Nome del Bean: Possiamo recuperare un Bean specifico per nome (di default è il nome del metodo).
BEAN SCOPE: SINGLETON E PROTOTYPE
Il comportamento (scope) dei Bean è fondamentale per la gestione della memoria:
Singleton (Default): Esiste una sola istanza in tutta l'app. Ogni getBean() restituisce lo stesso oggetto.
Per DAO, Service, Controller (oggetti senza stato interno variabile).
Attenzione al Singleton: se modifichi una proprietà di un Bean Singleton in un punto dell'app, quella modifica
sarà visibile ovunque, perché l'oggetto è lo stesso

Prototype: Viene creata una nuova istanza ogni volta che viene richiesto il Bean.
Per Oggetti che mantengono dati specifici per un'operazione e non devono essere condivisi.



@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@LEZIONE 2 Spring@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

















@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@LEZIONE 4@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
In questa lezione vedremo la relazione con il DB che ci verrà facilitato dal jpa che ci farà tutto lui, direttamente
dallo spring initializer come per l'aggiunta di lombok attraverso le dependencies (Spring Data Jpa),(PostgreSQL Driver).
successivamente dovremo collegarci al database prima di tutto creiamo il progetto in pgAdmin, poi aggiungiamo in
spring.datasource.url=jdbc:postgresql://localhost5432/u5d4
spring.datasource.username=postgres
spring.datasource.password=1234
spring.datasource.driver-class-name=org.postgresql.Driver
spring.jpa.hibernate.ddl-auto=update
dopodichè runniamo per vedere gli errori e dopo se non ci sono errori andremo a creare le entities come sempre,
aggiungendo le varie annotazioniii  come @Entity, @Table etc. successivamente i classici attributi, con
@Id
@GeneretedValue(strategy = GenerationType.IDENTITY) @Column(name = profile_img" nullable = false)
successivamente costruttori getter e setter e i toString in caso non volessimo il setter sull'id
@Setter(AccessLevel.NONE) e lo stesso per il @Getter nella password. successivamente aggiungiamo una seconda classe con
 relazione ManyToOne di BlogPost  mettiamo tutti gli attributi costruttore, getter e setter dei tostring e runniamo
 dinuovo per vedere il DB. a questo punto serviranno i dao che saranno divisi in due parti grazie anche alle repository
che si occuperà di tutti i metodi base per interagire con la tabella, invece per la tutela del codice come eccezioni
ecceterà verrà utilizzata la classe service che si occupa di eseguire controlli eccezioni log, e anche service sarà un
component ma con annotazione @Service quindi la struttura adesso sarà per ogni tabella un service e una repository che
sostituiranno i nostri dao. inoltre la Repo non è una classe ma un'interface che estende la
JpaRepository<classe entità di riferimento, tipo di dato dell'id>, questo è ciò che ci consentirà di creare tutto il CRUD
base come save, findById, findAll e possiamo aggiungere anche altri metodi custom come queries etc.
il prossimo passo del progetto è quello di creare un package delle repositories al cui interno aggiungeremo un interface
con annotazione @Rpeository ed extends JpaRepository<User, Long>, a questo punto possiamo aggiungere un runner per
vedere tutti i metodi che volevamo, iniziamo con implements ComandLineRunner{} al cui interno
private final UserRepository userRepository successivamente creiamo il costruttore con l'@Autowired e nel
@Override public void run  (String... args) throws Exception {} aggiungiamo il faker e un User con userRepository.save
dopo il print vedremo due user all'interno.
successivamente andiamo a creare un package Service con all'interno una classe BlogService e servirà da intermediario
che serve per aggiungere ulteriori logiche controlli log etc. durante le interazioni con db,poichè i metodi nella repository
non ci sono. quindi ad esempio nelle repo si salva e basta mentre le service ci serve per controlla re che l'email sia
unica, che la password rispetti determinati criteri anche ad esempio aggiungere un log di avvenuto salvattaggio può
essere fatta dal service o anche la gestione delle eccezioni custom è un dovere del service e non della repo. per esempio
per un metodo saveUser iniziamo aggiungendo il costruttore con l'@Autowired per per implementare le Repository all'interno.
successivamente si possono fare diversi passaggi come
1 contolla che l'email non sia già in uso
2 effettua altri controlli di validazioni sui dati inseriti
if (newUser.getName().length() < 2) throw new validationException ("il nome non può essere più corto di 2 caratteri")
3 aggiungi ulteriori dati server genereted
4 salvo effettivamente l'utente tramite repository
this.usersRepository.save(newUser);
5 log di avvenuto salvataggio: S.o.p("l'uttente è stato salvato correttamente " + newUser.getSurname());
successiavamente aggiungiamo un try catch nel runner per le eccezzioni di id doppi, dopo possiamo fare dei metodi per modificare e poi anche per eliminare un user
questo lo possiamo fare grazie al Userservice creando il metodo con public void  findByIdAndUpdate (long userId, User update){}
al cui interno:

mettiamo User found = this.findById(userId);


